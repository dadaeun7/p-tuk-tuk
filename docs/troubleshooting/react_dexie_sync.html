<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React & Dexie 트러블슈팅: Stale Prop 동기화 문제</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f1f5f9;
        }
        .timeline-item {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        /* 색상 변경: 트러블슈팅/해결 주제에 맞게 파란색 계열로 변경 */
        .timeline-item.active {
            background-color: #3b82f6; /* 파란색 */
            color: white;
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .timeline-item.active .timeline-phase {
            color: white;
        }
        .timeline-item:not(.active):hover {
            background-color: #eff6ff; /* 연한 파란색 계열 */
            transform: translateY(-2px);
        }
        .content-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .code-block {
            background-color: #1e293b;
            color: #e2e8f0;
            font-family: 'Courier New', Courier, monospace;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-size: 0.875rem;
        }
        .text-error { color: #dc3545; }
        .text-success { color: #3b82f6; } /* 파란색 성공 표시 */
    </style>
</head>
<body class="text-slate-800">

    <main class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">React & Dexie: Stale Prop 동기화 트러블슈팅</h1>
            <p class="mt-2 text-lg text-slate-600">DB 비동기 업데이트 후 UI가 반영되지 않거나 새로고침 시 초기화되는 문제 해결 기록.</p>
        </header>

        <nav id="timeline-nav" class="flex flex-col md:flex-row justify-center items-center gap-2 md:gap-4 mb-12">
            </nav>

        <div id="content-area">
            </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const timelineNav = document.getElementById('timeline-nav');
            const contentArea = document.getElementById('content-area');
            let currentPhaseIndex = 0;

            const caseFiles = [
                {
                    phase: "Phase 1",
                    title: "문제 정의 및 초기 가설",
                    icon: "🔥",
                    content: {
                        symptom: "자식 컴포넌트의 `useCallback` 함수에서 Dexie DB 업데이트를 성공했으나, <span class='text-error'>UI에 반영되지 않거나</span> 새로고침 시 `null` 값으로 되돌아감.",
                        hypothesis: "상태 불변성(`setGroupData`) 로직에 문제가 있거나, `useCallback`이 오래된 상태를 참조하는 클로저(Closure) 문제일 것이다.",
                        investigation: [
                            "`setGroupData(prev => {...})` 패턴을 사용하여 불변성 원칙을 준수했음을 확인.",
                            "`console.log`로 `setGroupData` 직후 새 상태는 올바르게 변경되었음을 확인.",
                            "결론: 상태 업데이트 자체는 성공했으나, 다른 로직이 이 값을 덮어쓰고 있음."
                        ],
                        breakthrough: "문제는 **상태 업데이트 자체가 아닌** <span class='text-success'>상태를 초기화하는 로직</span>에 있음을 파악."
                    }
                },
                {
                    phase: "Phase 2",
                    title: "단일 진실 근원(SSOT) 충돌",
                    icon: "🚨",
                    content: {
                        symptom: "새로고침 시 `useEffect`가 실행되며, `useCallback`에서 DB에 저장한 최신 상태가 `null` 값으로 덮어씌워짐.",
                        hypothesis: "부모에게서 받는 `orders` Prop이 DB의 최신 상태를 반영하지 못하고, 이 Prop이 `useEffect`를 통해 로컬 상태를 강제로 초기화하고 있다.",
                        investigation: [
                            "자식의 DB 업데이트가 부모의 `orders` Prop을 변경시키지 못하는 **React 단방향 데이터 흐름** 확인.",
                            "`useEffect([orders])`는 Prop이 바뀔 때마다 실행되어, 오래된 `orders` Prop을 기반으로 `groupData`를 재초기화하고 있었음.",
                            "결과: **DB (Local) vs. Prop (Parent)** 간의 데이터 동기화 불일치가 근본 원인."
                        ],
                        breakthrough: "자식의 DB 업데이트 후 **<span class='text-success'>부모의 `orders` Prop</span>**을 강제로 최신화해야 한다는 전략적 목표 설정."
                    }
                },
                {
                    phase: "Phase 3",
                    title: "`useQuery` Refetch를 통한 Prop 동기화",
                    icon: "🔄",
                    content: {
                        symptom: "Props를 동기화하기 위해 부모에게 새로운 갱신 함수를 요청해야 하는 상황. 기존에 `useQuery` 사용 중.",
                        hypothesis: "부모 컴포넌트가 `useQuery`에서 제공하는 `refetch` 함수를 자식에게 Props로 전달하여 갱신 신호를 보낼 수 있다.",
                        investigation: [
                            "부모 컴포넌트에서 `refetch` 함수를 `onOrdersUpdate` Prop으로 자식에게 전달하도록 구조 변경.",
                            "자식 컴포넌트의 `useCallback` 내부에서 Dexie 업데이트 성공 직후, `onOrdersUpdate()` (즉, `refetch`) 호출 로직 추가.",
                            "결과: `refetch` 호출로 부모의 `useQuery`가 DB의 최신 데이터를 가져옴. 이는 곧바로 자식의 `orders` Prop 변경으로 이어짐."
                        ],
                        breakthrough: "DB 변경 후 **`onOrdersUpdate()`** 호출을 통해 **<span class='text-success'>부모-자식 컴포넌트 간의 상태 동기화 파이프라인</span>**을 구축."
                    }
                },
                {
                    phase: "Phase 4",
                    title: "최종 결론 및 기대 효과",
                    icon: "✅",
                    content: {
                        symptom: "`refetch` 함수 호출만으로 새로고침 문제 및 실시간 반영 문제가 모두 해결됨.",
                        hypothesis: "비동기 DB/API 업데이트 시, 로컬 상태를 직접 조작하기보다 **데이터 소스(Prop)를 갱신**하는 것이 React의 정석 패턴이다.",
                        investigation: [
                            "DB I/O (Dexie) 후 `refetch`로 인한 부모 Prop 갱신 -> 자식 `useEffect([orders])` 실행 -> `groupData` 올바르게 갱신되는 완전한 사이클 확인.",
                            "Year/Month 변경 시 `useQuery`의 자동 refetch 기능은 그대로 유지됨.",
                            "결론: `refetch`를 통한 Prop 동기화는 **단일 진실 근원(SSOT)**을 중앙(Parent)에 두는 실무적인 최적의 해결책."
                        ],
                        breakthrough: "<strong>`useQuery`의 `refetch` 함수를 통한 Prop 동기화 전략을 최종 채택.</strong> React의 비동기 환경에서 외부 데이터 저장소(Dexie)를 사용하는 가장 모범적이고 안정적인 아키텍처 구축."
                    }
                }
            ];

            function render() {
                // 타임라인 렌더링
                timelineNav.innerHTML = '';
                caseFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = `timeline-item flex-1 p-3 md:p-4 rounded-lg shadow-md bg-white border border-slate-200 text-center ${index === currentPhaseIndex ? 'active' : ''}`;
                    item.dataset.index = index;
                    item.innerHTML = `
                        <div class="text-3xl mb-1">${file.icon}</div>
                        <div class="font-bold text-sm md:text-base">${file.title}</div>
                        <div class="timeline-phase text-xs text-slate-500">${file.phase}</div>
                    `;
                    timelineNav.appendChild(item);
                });

                // 콘텐츠 렌더링
                const file = caseFiles[currentPhaseIndex];
                contentArea.innerHTML = '';
                const contentDiv = document.createElement('div');
                contentDiv.className = 'content-fade-in bg-white p-6 md:p-8 rounded-lg shadow-lg border border-slate-200';
                
                let investigationItems = file.content.investigation
                    .map(item => `<li class="flex items-start"><span class="mr-2 text-blue-500">→</span><span>${item}</span></li>`)
                    .join('');

                contentDiv.innerHTML = `
                    <h2 class="text-2xl font-bold mb-4 text-slate-900">${file.icon} ${file.title}</h2>
                    <div class="space-y-6">
                        <div>
                            <h3 class="font-semibold text-lg text-red-600 mb-2">증상</h3>
                            <p class="text-slate-700">${file.content.symptom}</p>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-yellow-600 mb-2">초기 가설 / 시도</h3>
                            <p class="text-slate-700">${file.content.hypothesis}</p>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-blue-600 mb-2">수사 및 단서 (시행착오 포함)</h3>
                            <ul class="space-y-2 text-slate-700">${investigationItems}</ul>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-green-600 mb-2">결정적 돌파구 / 결론</h3>
                            <p class="text-slate-700 font-medium">${file.content.breakthrough}</p>
                        </div>
                    </div>
                `;
                contentArea.appendChild(contentDiv);
            }
            
            timelineNav.addEventListener('click', (e) => {
                const target = e.target.closest('.timeline-item');
                if (target && target.dataset.index) {
                    currentPhaseIndex = parseInt(target.dataset.index, 10);
                    render();
                }
            });

            // 초기 렌더링
            render();
        });
    </script>

</body>
</html>