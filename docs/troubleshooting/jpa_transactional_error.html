<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JPA & 트랜잭션: 동시성 문제 해결기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f1f5f9;
        }
        .timeline-item {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .timeline-item.active {
            background-color: #3b82f6;
            color: white;
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .timeline-item.active .timeline-phase {
            color: white;
        }
        .timeline-item:not(.active):hover {
            background-color: #dbeafe;
            transform: translateY(-2px);
        }
        .content-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .code-block {
            background-color: #1e293b;
            color: #e2e8f0;
            font-family: 'Courier New', Courier, monospace;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="text-slate-800">

    <main class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">사건 파일: JPA 영속성 & 동시성 미스터리</h1>
            <p class="mt-2 text-lg text-slate-600">며칠에 걸친 디버깅, 눈물의 트러블슈팅 여정.</p>
        </header>

        <nav id="timeline-nav" class="flex flex-col md:flex-row justify-center items-center gap-2 md:gap-4 mb-12">
            </nav>

        <div id="content-area">
            </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const timelineNav = document.getElementById('timeline-nav');
            const contentArea = document.getElementById('content-area');
            let currentPhaseIndex = 0;

            const caseFiles = [
                {
                    phase: "1단계",
                    title: "데이터 덮어쓰기 & 중복 키",
                    icon: "👻",
                    content: {
                        symptom: "하나의 주문(`RecycleOrder`)에 여러 재활용 정보(`Material`)를 저장하면, 이전에 저장된 `Material`의 연결 정보(FK)가 새로운 주문의 것으로 **덮어씌워지는 현상**이 발생. 이 문제를 해결하기 위해 `Material` 엔티티를 재사용하지 않고 새로 생성했더니, 이번에는 **`Duplicate entry 'PET' for key ...`** 오류가 발생하며 저장이 실패.",
                        hypothesis: "단순한 객체 재사용 문제 또는 JPA의 세션 캐시 문제로 추정.",
                        investigation: [
                            "`Material` 엔티티는 재활용 물질의 종류(`PET`, `종이` 등)를 정의하는 **메타데이터** 역할을 함.",
                            "DB 스키마에는 `Material`의 `name` 컬럼에 **`UNIQUE` 제약 조건**이 걸려 있어 중복된 이름의 저장을 막고 있었음.",
                            "동시에 `Material` 엔티티는 `MatchItemComposition`과 **`@ManyToOne` 관계**로 설정되어, 단 하나의 부모만 가질 수 있는 **외래 키(FK)**를 가지고 있었음.",
                        ],
                        breakthrough: "**엔티티의 역할이 충돌**하고 있었음. `Material`은 `UNIQUE` 제약 조건 때문에 여러 곳에서 재사용되어야 하는 **N(다)**의 입장이면서, 동시에 `@ManyToOne` FK 때문에 단 하나의 부모만 가져야 하는 **1**의 입장이었음. 이 모순적인 설계가 덮어쓰기와 중복 키 오류의 근본 원인이었음. <br/><br/> **➡️ 해결책: `Material`과 `MatchItemComposition`의 관계를 `@ManyToMany`로 수정하고, `Material` 테이블에서 외래 키를 제거하여 순수한 메타데이터 역할을 하도록 역할을 명확히 함.**"
                    }
                },
                {
                    phase: "2단계",
                    title: "유령 엔티티와 영속성 함정",
                    icon: "⚔️",
                    content: {
                        symptom: "엔티티 관계를 수정하는 과정에서 **`detached entity passed to persist`** (영속성 분리 오류)와 **`TransientObjectException`** (임시 객체 참조 오류)이 연쇄적으로 발생. 엔티티를 저장하는 순서가 꼬이면서 JPA가 객체의 상태를 추적하지 못함.",
                        hypothesis: "`Cascade` 설정이 잘못되었거나, 부모 엔티티가 저장되기 전에 자식 엔티티가 부적절하게 참조되었다고 판단.",
                        investigation: [
                            "자식 엔티티의 `@ManyToOne` 관계에 불필요한 **`cascade = CascadeType.PERSIST`** 옵션이 설정되어 있었음. 이는 자식을 저장할 때 이미 영속 상태인 부모를 다시 저장하려는 잘못된 명령을 유발.",
                            "`@OneToMany` 관계에서 양방향 연관관계를 설정하는 **헬퍼 메서드(`addMatchItem()`)** 사용이 누락되어, 부모와 자식 간의 연결이 메모리상에서만 이루어지고 영속성 컨텍스트에는 반영되지 않음을 발견.",
                        ],
                        breakthrough: "JPA의 **영속성 전이(Cascade)**와 **생명주기**에 대한 이해 부족이 원인이었음. 자식이 부모의 생명주기를 관리하려 하거나, 부모가 자식을 영속성 컨텍스트에 포함시키지 못하면 JPA는 데이터 정합성을 위해 예외를 발생시킴. <br/><br/> **➡️ 해결책: 모든 `@ManyToOne` 관계에서 `CascadeType.PERSIST`를 제거하고, 모든 `@OneToMany` 관계에는 `CascadeType.ALL`을 유지하며 반드시 헬퍼 메서드를 통해 양방향 관계를 설정하여 부모가 자식을 명확히 소유하도록 수정.**"
                    }
                },
                {
                    phase: "3단계",
                    title: "잠금(Lock)과 교착 상태의 전쟁",
                    icon: "⏳",
                    content: {
                        symptom: "앞선 문제들을 해결하기 위해 트랜잭션을 세분화(`REQUIRES_NEW`)하자, **`ObjectOptimisticLockingFailureException`** (낙관적 락 충돌)이 발생했고, 최종적으로는 **`Lock wait timeout exceeded`** (락 대기 시간 초과)라는 최악의 DB 락 오류가 발생하며 시스템이 멈춤.",
                        hypothesis: "비동기(`@Async`) 환경으로 인해 동시성 충돌이 발생한다고 판단, 트랜잭션을 분리하고 재시도(`@Retryable`) 로직을 추가하면 해결될 것이라 예상. **(이것이 가장 큰 패착이었음)**",
                        investigation: [
                            "하나의 비즈니스 로직을 여러 개의 **`@Transactional(propagation = Propagation.REQUIRES_NEW)`** 메서드로 분리.",
                            "`REQUIRES_NEW`는 호출될 때마다 새로운 DB 커넥션을 획득하고 즉시 커밋을 시도함.",
                            "분리된 트랜잭션 A가 특정 테이블에 락을 건 상태에서, 또 다른 분리된 트랜잭션 B가 해당 테이블에 접근하려 하면서 **DB 락 경합**이 극도로 심화됨.",
                            "결과적으로, 트랜잭션을 분리한 조치가 오히려 락 문제를 악화시키고 시스템 전체를 교착상태에 빠뜨림.",
                        ],
                        breakthrough: "**'하나의 비즈니스 로직은 하나의 트랜잭션으로 처리되어야 한다'**는 **Unit of Work 패턴**을 위배한 것이 원인이었음. 복잡한 문제를 해결하려다 기본 원칙을 놓침.<br/><br/> **➡️ 최종 해결책: 불필요하게 분리했던 모든 `REQUIRES_NEW` 속성을 제거하고, 모든 하위 서비스 메서드가 기본값인 `REQUIRED`를 따르도록 변경. 비즈니스 로직 전체를 감싸는 최상위 서비스 메서드에 단 하나의 `@Transactional`을 적용하여 모든 DB 작업을 하나의 원자적 단위로 통합.**"
                    }
                },
                {
                    phase: "사건 종결",
                    title: "최종 교훈",
                    icon: "✅",
                    content: {
                        symptom: "완벽하게 동작하는 동시성 데이터 처리 기능. DB 락, 데이터 덮어쓰기, 영속성 오류가 모두 해결됨.",
                        hypothesis: "근본적인 엔티티 설계를 바로잡고, Spring 트랜잭션의 기본 원칙을 준수하면 복잡한 동시성 문제는 자연스럽게 해결된다.",
                        investigation: [
                            "**엔티티 설계가 아키텍처의 전부다:** 잘못된 엔티티 관계(1:N vs N:M)는 JPA의 모든 메커니즘을 오작동하게 만드는 근본 원인이었다.",
                            "**Unit of Work 패턴을 신뢰하라:** Spring의 `@Transactional`(기본값 `REQUIRED`)은 JPA가 모든 변경 사항을 메모리에 모아두었다가, 트랜잭션이 끝날 때 단 한 번의 `flush`로 DB에 반영하여 락 시간을 최소화한다. 이 원칙을 믿고 따라야 한다.",
                            "**`REQUIRES_NEW`는 독이다:** `REQUIRES_NEW`는 트랜잭션의 원자성을 깨뜨리고 DB 커넥션을 추가로 소모하며, 락 경합과 교착상태를 유발하는 주범이다. 매우 예외적인 경우에만 사용해야 한다.",
                        ],
                        breakthrough: "이 경험은 복잡한 시스템에서 발생하는 오류는 단편적인 코드 수정이 아닌, **구조적인 관점**에서 접근해야 함을 증명하는 중요한 자산이 되었다. 이 끈질긴 트러블슈팅의 경험을 통해 JPA의 영속성, 동시성, 트랜잭션 관리에 대한 깊은 이해를 체득하게 되었다."
                    }
                }
            ];

            function render() {
                // 타임라인 렌더링
                timelineNav.innerHTML = '';
                caseFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = `timeline-item flex-1 p-3 md:p-4 rounded-lg shadow-md bg-white border border-slate-200 text-center ${index === currentPhaseIndex ? 'active' : ''}`;
                    item.dataset.index = index;
                    item.innerHTML = `
                        <div class="text-3xl mb-1">${file.icon}</div>
                        <div class="font-bold text-sm md:text-base">${file.title}</div>
                        <div class="timeline-phase text-xs text-slate-500">${file.phase}</div>
                    `;
                    timelineNav.appendChild(item);
                });

                // 콘텐츠 렌더링
                const file = caseFiles[currentPhaseIndex];
                contentArea.innerHTML = '';
                const contentDiv = document.createElement('div');
                contentDiv.className = 'content-fade-in bg-white p-6 md:p-8 rounded-lg shadow-lg border border-slate-200';
                
                let investigationItems = file.content.investigation
                    .map(item => `<li class="flex items-start"><span class="mr-2 text-blue-500">-</span><span>${item}</span></li>`)
                    .join('');

                contentDiv.innerHTML = `
                    <h2 class="text-2xl font-bold mb-4 text-slate-900">${file.icon} ${file.title}</h2>
                    <div class="space-y-6">
                        <div>
                            <h3 class="font-semibold text-lg text-red-600 mb-2">증상</h3>
                            <p class="text-slate-700">${file.content.symptom}</p>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-yellow-600 mb-2">초기 가설</h3>
                            <p class="text-slate-700">${file.content.hypothesis}</p>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-blue-600 mb-2">수사 및 단서</h3>
                            <ul class="space-y-2 text-slate-700">${investigationItems}</ul>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-green-600 mb-2">결정적 돌파구 / 결론</h3>
                            <p class="text-slate-700 font-medium">${file.content.breakthrough}</p>
                        </div>
                    </div>
                `;
                contentArea.appendChild(contentDiv);
            }
            
            timelineNav.addEventListener('click', (e) => {
                const target = e.target.closest('.timeline-item');
                if (target && target.dataset.index) {
                    currentPhaseIndex = parseInt(target.dataset.index, 10);
                    render();
                }
            });

            // 초기 렌더링
            render();
        });
    </script>

</body>
</html>