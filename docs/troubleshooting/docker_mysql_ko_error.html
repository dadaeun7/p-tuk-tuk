<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MySQL 인코딩 문제: Latin1과의 전쟁 기록</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f1f5f9;
        }
        .timeline-item {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .timeline-item.active {
            background-color: #007bff; /* 파란색 계열로 변경 */
            color: white;
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .timeline-item.active .timeline-phase {
            color: white;
        }
        .timeline-item:not(.active):hover {
            background-color: #e6f3ff; /* 연한 파란색 계열로 변경 */
            transform: translateY(-2px);
        }
        .content-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .code-block {
            background-color: #1e293b;
            color: #e2e8f0;
            font-family: 'Courier New', Courier, monospace;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-size: 0.875rem;
        }
        .text-error { color: #dc3545; }
        .text-warning { color: #ffc107; }
    </style>
</head>
<body class="text-slate-800">

    <main class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">사건 파일: MySQL Latin1 인코딩 미스터리</h1>
            <p class="mt-2 text-lg text-slate-600">Spring + React 환경에서 Docker MySQL 인코딩 문제를 해결한 기록.</p>
        </header>

        <nav id="timeline-nav" class="flex flex-col md:flex-row justify-center items-center gap-2 md:gap-4 mb-12">
            </nav>

        <div id="content-area">
            </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const timelineNav = document.getElementById('timeline-nav');
            const contentArea = document.getElementById('content-area');
            let currentPhaseIndex = 0;

            const caseFiles = [
                {
                    phase: "1단계",
                    title: "기묘한 깨짐 현상",
                    icon: "❓",
                    content: {
                        symptom: "React 요청(A) 데이터는 DB에 <span class='text-error'>???</span>로 저장되어도 Java 조회 시 <span class='text-success'>정상 출력</span>되나, SQL 파일 주입(B) 데이터는 DB에 정상 저장되어도 Java 조회 시 <span class='text-error'>깨진 문자</span>로 출력됨.",
                        hypothesis: "Java/JDBC 레이어의 인코딩 설정 오류. 특히 JDBC URL에 인코딩 옵션 누락 의심.",
                        investigation: [
                            "JDBC URL에 `characterEncoding=UTF-8`, `serverTimezone=Asia/Seoul` 등 옵션 추가.",
                            "`DataSourceConfig` Bean을 Java 코드로 정의하여 인코딩 속성을 강제 주입 시도.",
                            "`EncodingDiagnosticRunner`를 통해 JVM 기본 인코딩(UTF-8) 정상 확인.",
                            "결과적으로 Java/JDBC 단의 어떤 설정도 B 방식의 깨짐 현상을 해결하지 못했으며, A 방식은 일종의 오류 상쇄 현상으로 추정됨."
                        ],
                        breakthrough: "문제의 근원이 Java가 아닌, **DB 서버와 클라이언트 간의 통신 초기 설정**에 있음을 확신하고 Docker 환경 디버깅으로 전환."
                    }
                },
                {
                    phase: "2단계",
                    title: "Latin1과의 충돌",
                    icon: "⚔️",
                    content: {
                        symptom: "DB의 테이블/데이터베이스 인코딩은 `utf8mb4`로 정상이나, 연결(Connection) 시 인코딩은 계속해서 `latin1`으로 설정됨.",
                        hypothesis: "Docker 환경 변수 또는 초기화 스크립트가 인코딩 기본값을 덮어쓰지 못하고 있음.",
                        investigation: [
                            "Shell에서 `SHOW VARIABLES LIKE 'character_set_%';` 실행 결과, `character_set_client`와 `character_set_connection`이 **<span class='text-error'>latin1</span>**인 것을 확인.",
                            "Docker Compose에 `MYSQL_CHARSET=utf8mb4`, `MYSQL_COLLATION` 등 **환경 변수** 추가 시도했으나 실패.",
                            "볼륨 마운트를 통한 **초기화 스크립트** (`/docker-entrypoint-initdb.d`)를 사용하여 인코딩 설정 강제 시도했으나 실패.",
                            "`command`에 `--character-set-client-handshake=FALSE`와 `--init-connect='SET NAMES utf8mb4'`를 직접 삽입하여 **오류만 유발**하고 삭제함."
                        ],
                        breakthrough: "환경 변수나 초기화 스크립트만으로는 MySQL 클라이언트 연결 시의 <span class='text-error'>latin1</span> 기본값을 강제할 수 없으며, **Configuration 파일**을 통한 강력한 오버라이드가 필요함을 인지."
                    }
                },
                {
                    phase: "3단계",
                    title: "보안 경고의 장벽",
                    icon: "🔒",
                    content: {
                        symptom: "`my.cnf` 파일을 마운트해도 설정이 적용되지 않고, 로그에 <span class='text-warning'>World-writable config file '/etc/mysql/conf.d/my.cnf' is ignored.</span> 경고가 지속적으로 출력.",
                        hypothesis: "MySQL 서버가 보안상의 이유로 호스트에서 마운트된 설정 파일의 광범위한 권한을 거부하고 있음.",
                        investigation: [
                            "MySQL 보안 가이드라인에 따라 설정 파일은 전역 쓰기 권한(World-writable)이 있어서는 안 됨을 파악.",
                            "Windows 환경에서는 호스트에서 `chmod`가 불가하므로, **Docker Entrypoint 단계에서 권한을 변경**해야 함을 결정.",
				"MYSQL 계정을 root가 아닌 사용자 계정으로, 로그인 계정 설정 해야함 파악"
                        ],
                        breakthrough: "`docker-compose.yml`의 `command`에 <span class='text-success'>chmod 644</span> 명령을 추가하여 권한 문제를 해결. 이로써 `my.cnf` 설정과 사용자 계정으로 설정 후 비로소 적용될 수 있는 길이 열림."
                    }
                },
                {
                    phase: "4단계",
                    title: "근본적인 해결",
                    icon: "✅",
                    content: {
                        symptom: "모든 통신 경로에서 한글 깨짐 현상이 완전히 사라짐.",
                        hypothesis: "DB 서버의 클라이언트/커넥션 인코딩을 강제로 통일하고, 데이터 파일 자체를 깨지지 않은 상태로 주입.",
                        investigation: [
                            "권한 문제가 해결된 후, `my.cnf`에 <span class='text-success'>init_connect = SET NAMES utf8mb4</span>를 추가하여 모든 비 슈퍼유저 연결 시 인코딩을 강제 통일.",
                            "깨진 백업 파일 대신, **UTF-8 (BOM 없음)**으로 저장된 새로운 SQL 스크립트를 주입하여 데이터 복구 완료.",
                        ],
                        breakthrough: "<strong>문제의 근본이 Java/JDBC가 아닌, Docker MySQL 컨테이너의 잘못된 기본 설정(latin1)임을 최종 확인.</strong> 불필요했던 Java/JDBC의 모든 인코딩 설정을 제거했음에도 불구하고 시스템이 완벽하게 동작하는 것을 확인함."
                    }
                }
            ];

            function render() {
                // 타임라인 렌더링
                timelineNav.innerHTML = '';
                caseFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = `timeline-item flex-1 p-3 md:p-4 rounded-lg shadow-md bg-white border border-slate-200 text-center ${index === currentPhaseIndex ? 'active' : ''}`;
                    item.dataset.index = index;
                    item.innerHTML = `
                        <div class="text-3xl mb-1">${file.icon}</div>
                        <div class="font-bold text-sm md:text-base">${file.title}</div>
                        <div class="timeline-phase text-xs text-slate-500">${file.phase}</div>
                    `;
                    timelineNav.appendChild(item);
                });

                // 콘텐츠 렌더링
                const file = caseFiles[currentPhaseIndex];
                contentArea.innerHTML = '';
                const contentDiv = document.createElement('div');
                contentDiv.className = 'content-fade-in bg-white p-6 md:p-8 rounded-lg shadow-lg border border-slate-200';
                
                let investigationItems = file.content.investigation
                    .map(item => `<li class="flex items-start"><span class="mr-2 text-blue-500">-</span><span>${item}</span></li>`)
                    .join('');

                contentDiv.innerHTML = `
                    <h2 class="text-2xl font-bold mb-4 text-slate-900">${file.icon} ${file.title}</h2>
                    <div class="space-y-6">
                        <div>
                            <h3 class="font-semibold text-lg text-red-600 mb-2">증상</h3>
                            <p class="text-slate-700">${file.content.symptom}</p>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-yellow-600 mb-2">초기 가설 / 시도</h3>
                            <p class="text-slate-700">${file.content.hypothesis}</p>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-blue-600 mb-2">수사 및 단서 (시행착오 포함)</h3>
                            <ul class="space-y-2 text-slate-700">${investigationItems}</ul>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-green-600 mb-2">결정적 돌파구 / 결론</h3>
                            <p class="text-slate-700 font-medium">${file.content.breakthrough}</p>
                        </div>
                    </div>
                `;
                contentArea.appendChild(contentDiv);
            }
            
            timelineNav.addEventListener('click', (e) => {
                const target = e.target.closest('.timeline-item');
                if (target && target.dataset.index) {
                    currentPhaseIndex = parseInt(target.dataset.index, 10);
                    render();
                }
            });

            // 초기 렌더링
            render();
        });
    </script>

</body>
</html>