<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>캐싱 전략 최적화: Hybrid Model 도입 보고서</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f1f5f9;
        }
        .timeline-item {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        /* 색상 변경: 캐싱/최적화 주제에 맞게 녹색 계열로 변경 */
        .timeline-item.active {
            background-color: #10b981; /* 에메랄드 그린 */
            color: white;
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .timeline-item.active .timeline-phase {
            color: white;
        }
        .timeline-item:not(.active):hover {
            background-color: #ecfdf5; /* 연한 녹색 계열 */
            transform: translateY(-2px);
        }
        .content-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .code-block {
            background-color: #1e293b;
            color: #e2e8f0;
            font-family: 'Courier New', Courier, monospace;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-size: 0.875rem;
        }
        .text-error { color: #dc3545; }
        .text-success { color: #10b981; } /* 녹색 성공 표시 */
    </style>
</head>
<body class="text-slate-800">

    <main class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">최적화 파일: 키워드 매칭 캐싱 Hybrid Model 도입</h1>
            <p class="mt-2 text-lg text-slate-600">성능과 관리 효율을 동시에 잡기 위한 Spring Backend 캐싱 전략 최종 결정 기록.</p>
        </header>

        <nav id="timeline-nav" class="flex flex-col md:flex-row justify-center items-center gap-2 md:gap-4 mb-12">
            </nav>

        <div id="content-area">
            </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const timelineNav = document.getElementById('timeline-nav');
            const contentArea = document.getElementById('content-area');
            let currentPhaseIndex = 0;

            const caseFiles = [
                {
                    phase: "Phase 1",
                    title: "문제 정의 및 초기 가설",
                    icon: "🔥",
                    content: {
                        symptom: "키워드 데이터 증가(Item-Keyword 약 180건, KeywordSpecific 약 1000건)에 따라 <span class='text-error'>DB 부하와 응답 지연</span> 문제 발생. 모든 캐싱 로직을 RedisTemplate으로 처리하여 코드 복잡성이 높음.",
                        hypothesis: "모든 키워드 데이터를 Redis에 캐싱하여 DB 부하를 해소하고, 데이터 성격에 따라 캐싱 도구를 이원화하여 관리 효율을 높여야 한다.",
                        investigation: [
                            "KeywordSpecific은 Item-Keyword와 다르게 단일 조회 목적이 강함을 파악.",
                            "Item-Keyword는 Material, Description 등 복합적인 DTO 변환이 필요함을 확인.",
                            "두 데이터의 조회 빈도와 데이터 양을 비교하며 최적의 캐싱 도구를 매핑하기 시작."
                        ],
                        breakthrough: "데이터의 **성격(복합성 vs. 단순성)**을 기준으로 캐싱 전략을 분리하는 <span class='text-success'>하이브리드 모델</span> 도입 결정."
                    }
                },
                {
                    phase: "Phase 2",
                    title: "Item-Keyword: 제어의 영역",
                    icon: "🛠️",
                    content: {
                        symptom: "Item-Keyword는 Entity 전체 저장 후 DTO로 변환하는 복잡한 후처리 로직이 필요.",
                        hypothesis: "복잡한 제어 로직을 위해 Spring의 자동화 계층을 건너뛰고 Low-Level 도구를 사용해야 한다.",
                        investigation: [
                            "RedisTemplate을 이용한 Bulk Load (putAll, multiSet) 방식이 초기 캐시 로딩에 가장 효율적임을 확인.",
                            "Entity 전체를 저장하고 Service Layer에서 DTO로 변환하는 기존 방식 유지.",
                            "결과: 캐시 데이터의 구조와 로딩 시점을 개발자가 완벽하게 제어할 수 있게 됨."
                        ],
                        breakthrough: "Item-Keyword는 <span class='text-success'>RedisTemplate</span>을 사용하여 **Bulk Load 및 복합 데이터 처리의 유연성**을 확보."
                    }
                },
                {
                    phase: "Phase 3",
                    title: "KeywordSpecific: 자동화의 영역",
                    icon: "🤖",
                    content: {
                        symptom: "KeywordSpecific 단일 조회 로직에 RedisTemplate 코드가 반복되어 가독성 저하.",
                        hypothesis: "단순 조회 목적의 데이터는 Spring AOP에게 관리를 위임해야 한다.",
                        investigation: [
                            "KeywordSpecific (약 1000건)의 단일 조회에 `@Cacheable`을 적용했을 때 RedisTemplate 직접 사용 대비 성능 저하는 무시할 수준임을 확인.",
                            "DB 조회, 캐시 존재 확인, 캐시 저장 로직을 Spring이 자동으로 처리하도록 구현.",
                            "결과: `getKeywordSpecificEntity(String keyword)` 메서드 호출 한 번으로 캐시 조회가 끝남."
                        ],
                        breakthrough: "KeywordSpecific은 <span class='text-success'>@Cacheable</span>을 사용하여 **코드의 단순성 및 유지보수성**을 극대화. Item-Keyword와의 **역할 분담**을 명확히 함."
                    }
                },
                {
                    phase: "Phase 4",
                    title: "최종 결론 및 기대 효과",
                    icon: "✅",
                    content: {
                        symptom: "하이브리드 모델 도입으로 모든 키워드 조회 과정이 DB가 아닌 Redis에서 즉각 처리됨.",
                        hypothesis: "성능 최적화와 코드 일관성이라는 두 마리 토끼를 잡을 수 있다.",
                        investigation: [
                            "DB I/O 부하 극적 감소 확인.",
                            "신규 개발자는 `@Cacheable`이 적용된 메서드만 사용하여 로직을 이해하기 쉬워짐.",
                            "향후 10,000건 이상의 키워드 데이터로 확장되어도 안정적인 성능 유지 가능."
                        ],
                        breakthrough: "<strong>데이터 성격 기반의 하이브리드 캐싱 전략을 최종 채택.</strong> Item-Keyword는 `RedisTemplate`으로 제어하고, KeywordSpecific은 `@Cacheable`로 자동화하여 실무적으로 가장 효율적인 아키텍처를 구축함."
                    }
                }
            ];

            function render() {
                // 타임라인 렌더링 (이전 HTML 파일의 JS 로직과 동일)
                timelineNav.innerHTML = '';
                caseFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = `timeline-item flex-1 p-3 md:p-4 rounded-lg shadow-md bg-white border border-slate-200 text-center ${index === currentPhaseIndex ? 'active' : ''}`;
                    item.dataset.index = index;
                    item.innerHTML = `
                        <div class="text-3xl mb-1">${file.icon}</div>
                        <div class="font-bold text-sm md:text-base">${file.title}</div>
                        <div class="timeline-phase text-xs text-slate-500">${file.phase}</div>
                    `;
                    timelineNav.appendChild(item);
                });

                // 콘텐츠 렌더링 (이전 HTML 파일의 JS 로직과 동일)
                const file = caseFiles[currentPhaseIndex];
                contentArea.innerHTML = '';
                const contentDiv = document.createElement('div');
                contentDiv.className = 'content-fade-in bg-white p-6 md:p-8 rounded-lg shadow-lg border border-slate-200';
                
                let investigationItems = file.content.investigation
                    .map(item => `<li class="flex items-start"><span class="mr-2 text-green-500">→</span><span>${item}</span></li>`)
                    .join('');

                contentDiv.innerHTML = `
                    <h2 class="text-2xl font-bold mb-4 text-slate-900">${file.icon} ${file.title}</h2>
                    <div class="space-y-6">
                        <div>
                            <h3 class="font-semibold text-lg text-red-600 mb-2">증상</h3>
                            <p class="text-slate-700">${file.content.symptom}</p>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-yellow-600 mb-2">초기 가설 / 시도</h3>
                            <p class="text-slate-700">${file.content.hypothesis}</p>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-blue-600 mb-2">수사 및 단서 (시행착오 포함)</h3>
                            <ul class="space-y-2 text-slate-700">${investigationItems}</ul>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg text-green-600 mb-2">결정적 돌파구 / 결론</h3>
                            <p class="text-slate-700 font-medium">${file.content.breakthrough}</p>
                        </div>
                    </div>
                `;
                contentArea.appendChild(contentDiv);
            }
            
            timelineNav.addEventListener('click', (e) => {
                const target = e.target.closest('.timeline-item');
                if (target && target.dataset.index) {
                    currentPhaseIndex = parseInt(target.dataset.index, 10);
                    render();
                }
            });

            // 초기 렌더링
            render();
        });
    </script>

</body>
</html>